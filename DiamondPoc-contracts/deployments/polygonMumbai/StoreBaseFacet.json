{
  "address": "0xE7EC7F742040752b1bd15ED7eb83D2c9762EEDbd",
  "abi": [
    {
      "inputs": [],
      "name": "getAddr",
      "outputs": [
        {
          "internalType": "address",
          "name": "myAddr",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getItemCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getItems",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "itemList",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_customer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_idx",
          "type": "uint256"
        }
      ],
      "name": "getItemsSoldToUser",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "itemCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_idx",
          "type": "uint256"
        }
      ],
      "name": "getSalesPerItem",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "itemCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2e3792a46cfa9c6b97d995d80d9b19c261ba51fe5fd5ea76012cc2003717ebf2",
  "receipt": {
    "to": null,
    "from": "0xDe3089d40F3491De794fBb1ECA109fAc36F889d0",
    "contractAddress": "0xE7EC7F742040752b1bd15ED7eb83D2c9762EEDbd",
    "transactionIndex": 0,
    "gasUsed": "318195",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000100000000000000000008040000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000001000000000000000000000200000000000000000080000000000000000000000000000000000000000004000000000000000000001000000000100000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xaee04e8af5a73abd149579f233e8f595aef6924f79f40fbeaf7c3757e9b35980",
    "transactionHash": "0x2e3792a46cfa9c6b97d995d80d9b19c261ba51fe5fd5ea76012cc2003717ebf2",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 29256722,
        "transactionHash": "0x2e3792a46cfa9c6b97d995d80d9b19c261ba51fe5fd5ea76012cc2003717ebf2",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000de3089d40f3491de794fbb1eca109fac36f889d0",
          "0x0000000000000000000000003a22c8bc68e98b0faf40f349dd2b2890fae01484"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000001dd8126fbe54c00000000000000000000000000000000000000000000000006e2f4d9854a739c000000000000000000000000000000000000000000000000717b52a4acff488200000000000000000000000000000000000000000000000006e117585e4e8e50000000000000000000000000000000000000000000000000717d3025d3fb2dce",
        "logIndex": 0,
        "blockHash": "0xaee04e8af5a73abd149579f233e8f595aef6924f79f40fbeaf7c3757e9b35980"
      }
    ],
    "blockNumber": 29256722,
    "cumulativeGasUsed": "318195",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0217810ba6203fb47863624cdcfce3e9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"getAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"myAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getItemCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getItems\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"itemList\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getItemsSoldToUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"itemCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getSalesPerItem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"itemCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PoC/facets/StoreBaseFacet.sol\":\"StoreBaseFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"contracts/PoC/facets/StoreBaseFacet.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\n// import basic store lib\\nimport {LibStore} from \\\"../libraries/LibOthers.sol\\\";\\n// import to be able to interact with \\\"enforcecontractowner\\\"\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\"; \\n// import some contracts we want to read functions from\\nimport {Counters} from \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ncontract StoreBaseFacet {\\n\\n    using Counters for Counters.Counter;\\n\\n    function getItemCount() external view returns (uint256 count){\\n        count = LibStore.diamondStorage().itemCounter.current();\\n    }\\n\\n    function getItems() external view returns (string[] memory itemList){\\n        itemList = LibStore.getItemsPerStore(address(0));\\n    }\\n\\n    function getItemsSoldToUser (address _customer, uint256 _idx) external view returns (uint256 itemCount) {\\n        itemCount = LibStore.diamondStorage().itemSalesPerCustomer[_customer][_idx];\\n    }\\n\\n    function getSalesPerItem (uint256 _idx) external view returns (uint256 itemCount) {\\n        itemCount = LibStore.diamondStorage().salesPerProduct[_idx];\\n        return itemCount;\\n    }\\n\\n    function getAddr() external view returns(address myAddr){\\n        myAddr = address(this);\\n    }\\n}\",\"keccak256\":\"0x36d4b5ad0dde422f56289acf4832c3fa0cb13bdea4507bbf3892266bff0e1653\"},\"contracts/PoC/interfaces/IDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\\n* EIP-2535 Diamonds\\n/******************************************************************************/\\n\\ninterface IDiamond {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\",\"keccak256\":\"0x1785467a8f0e289da4c60b03b9055b8acb6fe0747b423b7e5d3082e562947de2\",\"license\":\"CC0-1.0\"},\"contracts/PoC/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\\n* EIP-2535 Diamonds\\n/******************************************************************************/\\n\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\n\\ninterface IDiamondCut is IDiamond {    \\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;    \\n}\\n\",\"keccak256\":\"0xed328a938a43c4fce96b8d05ce142a13497cab3a65c1e5cacfae3048053cbe1b\",\"license\":\"CC0-1.0\"},\"contracts/PoC/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\\n* EIP-2535 Diamonds\\n/******************************************************************************/\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror NoSelectorsGivenToAdd();\\nerror NotContractOwner(address _user, address _contractOwner);\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\nerror IncorrectFacetCutAction(uint8 _action);\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n        //extra variables added\\n        string location;\\n        uint256 creationTimestamp;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        if(msg.sender != diamondStorage().contractOwner) {\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\n        }        \\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\n            if(functionSelectors.length == 0) {\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\n            }\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamond.FacetCutAction.Add) {\\n                addFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\n                replaceFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\n                removeFunctions(facetAddress, functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction(uint8(action));\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        if(_facetAddress == address(0)) {\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);                \\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if(oldFacetAddress != address(0)) {\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\n            }            \\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        if(_facetAddress == address(0)) {\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\n        }\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\n            if(oldFacetAddress == address(this)) {\\n                revert CannotReplaceImmutableFunction(selector);\\n            }\\n            if(oldFacetAddress == _facetAddress) {\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\n            }\\n            if(oldFacetAddress == address(0)) {\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\n            }\\n            // replace old facet address\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        if(_facetAddress != address(0)) {\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\n        }        \\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\n            }\\n            \\n            \\n            // can't remove immutable functions -- functions defined directly in the diamond\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\n                revert CannotRemoveImmutableFunction(selector);\\n            }\\n            // replace selector with last selector\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }        \\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if(contractSize == 0) {\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\n        }        \\n    }\\n}\\n\",\"keccak256\":\"0x71413973a969720dca1a57333fef861a1ca8d01d1711f1b7b748f502e95c9192\",\"license\":\"CC0-1.0\"},\"contracts/PoC/libraries/LibOthers.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {Counters} from \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\nlibrary LibStore {\\n\\n    using Counters for Counters.Counter;\\n    error ItemNotSoldAtStore();\\n    error ItemNotAvailable();\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage.store\\\");\\n    \\n\\n    struct StoreState {\\n\\n        Counters.Counter itemCounter;\\n        mapping(uint256 => string) productName;\\n        mapping(uint256 => bool) isProductAvailable;\\n        mapping(uint256 => address) productStore; // maps prodcut to allowed store\\n        mapping(uint256 => uint256) salesPerProduct;\\n        mapping(address => mapping(uint256 => uint256)) itemSalesPerCustomer;\\n        mapping(address => uint256) salesPerCustomer;\\n    }\\n\\n    function diamondStorage() internal pure returns (StoreState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function  isStoreOfProduct(address store, uint256 _idx) internal view  {\\n        if(store != diamondStorage().productStore[_idx]){\\n            revert ItemNotSoldAtStore();\\n        }        \\n    }\\n\\n    function isProductAvailable(uint256 _idx) internal view {\\n        if(!diamondStorage().isProductAvailable[_idx]){\\n            revert ItemNotAvailable();\\n        }\\n    }\\n\\n    function getItemsPerStore(address storeAddr) internal view returns (string[] memory itemList){\\n        StoreState storage ds = diamondStorage();\\n        uint256 nItems = ds.itemCounter.current();\\n        itemList = new string[](nItems);\\n        uint256 i = 0;\\n        for(uint256 itemIndex = 1 ; itemIndex <= nItems ; itemIndex ++){\\n            if(storeAddr == address(0) || (ds.isProductAvailable[itemIndex] && ds.productStore[itemIndex] == storeAddr)){\\n                itemList[i]= ds.productName[itemIndex];\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function buyItem (uint256 _idx, address storeAddr) internal {\\n        isStoreOfProduct(storeAddr,_idx);\\n        isProductAvailable(_idx);\\n        StoreState storage  ds = diamondStorage();\\n        ds.salesPerProduct[_idx]++;\\n        ds.itemSalesPerCustomer[msg.sender][_idx]++;\\n        ds.salesPerCustomer[msg.sender]++;\\n    }\\n\\n    function addItem (string memory itemName, address storeAddr) internal {\\n        StoreState storage ds = diamondStorage();\\n        ds.itemCounter.increment();\\n        ds.productName[ds.itemCounter.current()] = itemName;\\n        ds.productStore[ds.itemCounter.current()] = storeAddr;\\n        ds.isProductAvailable[ds.itemCounter.current()] = true;\\n    }\\n}\\n\\nlibrary LibMeatStore {\\n\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage.meat\\\");\\n  struct StoreState {\\n      string butcherName;\\n  }\\n\\n  function diamondStorage() internal pure returns (StoreState storage ds) {\\n      bytes32 position = DIAMOND_STORAGE_POSITION;\\n      assembly {\\n          ds.slot := position\\n      }\\n  }\\n\\n  function setButcherName (string memory _butcherName) internal {\\n    StoreState storage storeState = diamondStorage();\\n    storeState.butcherName = _butcherName;\\n  }\\n\\n  function getButcherName() internal view returns (string memory) {\\n    StoreState storage storeState = diamondStorage();\\n    return storeState.butcherName;\\n  }\\n\\n}\\n\\nlibrary LibBeerWineStore {\\n\\n  error UnderageCustomer();  \\n\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage.beer\\\");\\n  struct StoreState {\\n      uint256 minAge;\\n  }\\n\\n  function diamondStorage() internal pure returns (StoreState storage ds) {\\n      bytes32 position = DIAMOND_STORAGE_POSITION;\\n      assembly {\\n          ds.slot := position\\n      }\\n  }\\n\\n  function setMinAge (uint256 _minAge) internal {\\n    StoreState storage storeState = diamondStorage();\\n    storeState.minAge = _minAge;\\n  }\\n\\n  function getMinAge() internal view returns (uint256) {\\n    StoreState storage storeState = diamondStorage();\\n    return storeState.minAge;\\n  }\\n\\n  function enforceMinAge(uint256 age) internal view {\\n    if(age < diamondStorage().minAge){\\n        revert UnderageCustomer();\\n    }    \\n  }\\n\\n\\n}\\n\\nlibrary LibPharmacyWineFacet {\\n\\n  error UnderageCustomer();  \\n\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage.beer\\\");\\n  struct StoreState {\\n      bool needPrescription;\\n  }\\n\\n  function diamondStorage() internal pure returns (StoreState storage ds) {\\n      bytes32 position = DIAMOND_STORAGE_POSITION;\\n      assembly {\\n          ds.slot := position\\n      }\\n  }\\n\\n  function setNeedPrescription (bool _need) internal {\\n    StoreState storage storeState = diamondStorage();\\n    storeState.needPrescription = _need;\\n  }\\n\\n\\n  function enforcePrescription(bool hasPrescription) internal view {\\n    if(diamondStorage().needPrescription && !hasPrescription){\\n        revert UnderageCustomer();\\n    }    \\n  }\\n\\n\\n}\",\"keccak256\":\"0xe77763260527410233461c05151cca3c60605a10853659eb8defd32f766b69b7\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506104cb806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063199513c11461005c578063410d59cc146100ae5780637749cf23146100c3578063a74c2bb6146100cb578063c4a03f59146100d9575b600080fd5b61009b61006a36600461031c565b60009081527f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac942602052604090205490565b6040519081526020015b60405180910390f35b6100b661012e565b6040516100a59190610335565b61009b61013f565b6040513081526020016100a5565b61009b6100e73660046103d0565b6001600160a01b039190911660009081527f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac94360209081526040808320938352929052205490565b606061013a6000610169565b905090565b600061013a7f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac93e5490565b7f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac93e8054606091908067ffffffffffffffff8111156101a9576101a9610408565b6040519080825280602002602001820160405280156101dc57816020015b60608152602001906001900390816101c75790505b509250600060015b828111610313576001600160a01b03861615806102375750600081815260028501602052604090205460ff168015610237575060008181526003850160205260409020546001600160a01b038781169116145b15610301576000818152600185016020526040902080546102579061041e565b80601f01602080910402602001604051908101604052809291908181526020018280546102839061041e565b80156102d05780601f106102a5576101008083540402835291602001916102d0565b820191906000526020600020905b8154815290600101906020018083116102b357829003601f168201915b50505050508583815181106102e7576102e7610458565b602002602001018190525081806102fd9061046e565b9250505b8061030b8161046e565b9150506101e4565b50505050919050565b60006020828403121561032e57600080fd5b5035919050565b6000602080830181845280855180835260408601915060408160051b87010192508387016000805b838110156103c257888603603f1901855282518051808852835b81811015610392578281018a01518982018b01528901610377565b818111156103a257848a838b0101525b50601f01601f19169690960187019550938601939186019160010161035d565b509398975050505050505050565b600080604083850312156103e357600080fd5b82356001600160a01b03811681146103fa57600080fd5b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b600181811c9082168061043257607f821691505b60208210810361045257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60006001820161048e57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220db641592bdc264fbe17937a1409069660005655f5f2248b10d95aaae6a40f5b764736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063199513c11461005c578063410d59cc146100ae5780637749cf23146100c3578063a74c2bb6146100cb578063c4a03f59146100d9575b600080fd5b61009b61006a36600461031c565b60009081527f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac942602052604090205490565b6040519081526020015b60405180910390f35b6100b661012e565b6040516100a59190610335565b61009b61013f565b6040513081526020016100a5565b61009b6100e73660046103d0565b6001600160a01b039190911660009081527f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac94360209081526040808320938352929052205490565b606061013a6000610169565b905090565b600061013a7f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac93e5490565b7f3e1203f9e3017e885f293b2817c8cf13c3f1a69d3fb206a868b5d52ad69ac93e8054606091908067ffffffffffffffff8111156101a9576101a9610408565b6040519080825280602002602001820160405280156101dc57816020015b60608152602001906001900390816101c75790505b509250600060015b828111610313576001600160a01b03861615806102375750600081815260028501602052604090205460ff168015610237575060008181526003850160205260409020546001600160a01b038781169116145b15610301576000818152600185016020526040902080546102579061041e565b80601f01602080910402602001604051908101604052809291908181526020018280546102839061041e565b80156102d05780601f106102a5576101008083540402835291602001916102d0565b820191906000526020600020905b8154815290600101906020018083116102b357829003601f168201915b50505050508583815181106102e7576102e7610458565b602002602001018190525081806102fd9061046e565b9250505b8061030b8161046e565b9150506101e4565b50505050919050565b60006020828403121561032e57600080fd5b5035919050565b6000602080830181845280855180835260408601915060408160051b87010192508387016000805b838110156103c257888603603f1901855282518051808852835b81811015610392578281018a01518982018b01528901610377565b818111156103a257848a838b0101525b50601f01601f19169690960187019550938601939186019160010161035d565b509398975050505050505050565b600080604083850312156103e357600080fd5b82356001600160a01b03811681146103fa57600080fd5b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b600181811c9082168061043257607f821691505b60208210810361045257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60006001820161048e57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220db641592bdc264fbe17937a1409069660005655f5f2248b10d95aaae6a40f5b764736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}