{
  "language": "Solidity",
  "sources": {
    "contracts/PoC/diamonds/BigStoreDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from  \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165} from \"../interfaces/IERC165.sol\";\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\n// This is used in diamond constructor\n// more arguments are added to this struct\n// this avoids stack too deep errors\nstruct DiamondArgs {\n    address owner;\n    address init;\n    bytes initCalldata;\n}\n\ncontract BigStoreDiamond {    \n\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, DiamondArgs memory _args) payable {\n        LibDiamond.setContractOwner(_args.owner);\n        LibDiamond.diamondCut(_diamondCut, _args.init, _args.initCalldata);\n\n        // Code can be added here to perform actions and set state variables.\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;\n        if(facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n             // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/PoC/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\nimport { IDiamond } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror NoSelectorsGivenToAdd();\nerror NotContractOwner(address _user, address _contractOwner);\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\nerror IncorrectFacetCutAction(uint8 _action);\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\nerror CannotReplaceImmutableFunction(bytes4 _selector);\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\nerror CannotRemoveImmutableFunction(bytes4 _selector);\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // function selector => facet address and selector position in selectors array\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\n        bytes4[] selectors;\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n        //extra variables added\n        string location;\n        uint256 creationTimestamp;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if(msg.sender != diamondStorage().contractOwner) {\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n        }        \n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n            if(functionSelectors.length == 0) {\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\n            }\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add) {\n                addFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Replace) {\n                replaceFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Remove) {\n                removeFunctions(facetAddress, functionSelectors);\n            } else {\n                revert IncorrectFacetCutAction(uint8(action));\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \n        if(_facetAddress == address(0)) {\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n        }\n        DiamondStorage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(ds.selectors.length);                \n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: Add facet has no code\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            if(oldFacetAddress != address(0)) {\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n            }            \n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\n            ds.selectors.push(selector);\n            selectorCount++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \n        DiamondStorage storage ds = diamondStorage();\n        if(_facetAddress == address(0)) {\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\n        }\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: Replace facet has no code\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\n            if(oldFacetAddress == address(this)) {\n                revert CannotReplaceImmutableFunction(selector);\n            }\n            if(oldFacetAddress == _facetAddress) {\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\n            }\n            if(oldFacetAddress == address(0)) {\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\n            }\n            // replace old facet address\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \n        DiamondStorage storage ds = diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        if(_facetAddress != address(0)) {\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n        }        \n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\n            }\n            \n            \n            // can't remove immutable functions -- functions defined directly in the diamond\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\n                revert CannotRemoveImmutableFunction(selector);\n            }\n            // replace selector with last selector\n            selectorCount--;\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\n            }\n            // delete last selector\n            ds.selectors.pop();\n            delete ds.facetAddressAndSelectorPosition[selector];\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }        \n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if(contractSize == 0) {\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\n        }        \n    }\n}\n"
    },
    "contracts/PoC/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\nimport { IDiamond } from \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {    \n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;    \n}\n"
    },
    "contracts/PoC/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/PoC/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/PoC/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/PoC/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\ninterface IDiamond {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}"
    },
    "contracts/PoC/diamonds/SmallStoreDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n*\n* Contract used to initialize state variables during deployment or upgrade\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\n// Adding parameters to the `init` or other functions you add here can make a single deployed\n// DiamondInit contract reusable accross upgrades, and can be used for multiple diamonds.\n\ncontract SmallStoreDiamondInit  {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n}\n"
    },
    "contracts/PoC/diamonds/SmallStoreDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from  \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165} from \"../interfaces/IERC165.sol\";\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\n// This is used in diamond constructor\n// more arguments are added to this struct\n// this avoids stack too deep errors\nstruct DiamondArgs {\n    address owner;\n    address init;\n    bytes initCalldata;\n}\n\ncontract SmallStoreDiamond {    \n\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, DiamondArgs memory _args) payable {\n        LibDiamond.setContractOwner(_args.owner);\n        LibDiamond.diamondCut(_diamondCut, _args.init, _args.initCalldata);\n\n        // Code can be added here to perform actions and set state variables.\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;\n        if(facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n             // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/PoC/diamonds/BigStoreDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n*\n* Contract used to initialize state variables during deployment or upgrade\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\n// Adding parameters to the `init` or other functions you add here can make a single deployed\n// DiamondInit contract reusable accross upgrades, and can be used for multiple diamonds.\n\ncontract BigStoreDiamondInit  {    \n\n    struct Args {\n        string location;\n        uint256 creationTimestamp;\n    }\n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init(Args memory args) external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n        ds.location = args.location;\n        ds.creationTimestamp = args.creationTimestamp;\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n}\n"
    },
    "contracts/PoC/facets/StoreBaseFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// import basic store lib\nimport {LibStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with \"enforcecontractowner\"\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\"; \n// import some contracts we want to read functions from\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract StoreBaseFacet {\n\n    using Counters for Counters.Counter;\n\n    function getItemCount() external view returns (uint256 count){\n        count = LibStore.diamondStorage().itemCounter.current();\n    }\n\n    function getItems() external view returns (string[] memory itemList){\n        itemList = LibStore.getItemsPerStore(address(0));\n    }\n\n    function getItemsSoldToUser (address _customer, uint256 _idx) external view returns (uint256 itemCount) {\n        itemCount = LibStore.diamondStorage().itemSalesPerCustomer[_customer][_idx];\n    }\n\n    function getSalesPerItem (uint256 _idx) external view returns (uint256 itemCount) {\n        itemCount = LibStore.diamondStorage().salesPerProduct[_idx];\n        return itemCount;\n    }\n\n    function getAddr() external view returns(address myAddr){\n        myAddr = address(this);\n    }\n}"
    },
    "contracts/PoC/libraries/LibOthers.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\nlibrary LibStore {\n\n    using Counters for Counters.Counter;\n    error ItemNotSoldAtStore();\n    error ItemNotAvailable();\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage.store\");\n    \n\n    struct StoreState {\n\n        Counters.Counter itemCounter;\n        mapping(uint256 => string) productName;\n        mapping(uint256 => bool) isProductAvailable;\n        mapping(uint256 => address) productStore; // maps prodcut to allowed store\n        mapping(uint256 => uint256) salesPerProduct;\n        mapping(address => mapping(uint256 => uint256)) itemSalesPerCustomer;\n        mapping(address => uint256) salesPerCustomer;\n    }\n\n    function diamondStorage() internal pure returns (StoreState storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function  isStoreOfProduct(address store, uint256 _idx) internal view  {\n        if(store != diamondStorage().productStore[_idx]){\n            revert ItemNotSoldAtStore();\n        }        \n    }\n\n    function isProductAvailable(uint256 _idx) internal view {\n        if(!diamondStorage().isProductAvailable[_idx]){\n            revert ItemNotAvailable();\n        }\n    }\n\n    function getItemsPerStore(address storeAddr) internal view returns (string[] memory itemList){\n        StoreState storage ds = diamondStorage();\n        uint256 nItems = ds.itemCounter.current();\n        itemList = new string[](nItems);\n        uint256 i = 0;\n        for(uint256 itemIndex = 1 ; itemIndex <= nItems ; itemIndex ++){\n            if(storeAddr == address(0) || (ds.isProductAvailable[itemIndex] && ds.productStore[itemIndex] == storeAddr)){\n                itemList[i]= ds.productName[itemIndex];\n                i++;\n            }\n        }\n    }\n\n    function buyItem (uint256 _idx, address storeAddr) internal {\n        isStoreOfProduct(storeAddr,_idx);\n        isProductAvailable(_idx);\n        StoreState storage  ds = diamondStorage();\n        ds.salesPerProduct[_idx]++;\n        ds.itemSalesPerCustomer[msg.sender][_idx]++;\n        ds.salesPerCustomer[msg.sender]++;\n    }\n\n    function addItem (string memory itemName, address storeAddr) internal {\n        StoreState storage ds = diamondStorage();\n        ds.itemCounter.increment();\n        ds.productName[ds.itemCounter.current()] = itemName;\n        ds.productStore[ds.itemCounter.current()] = storeAddr;\n        ds.isProductAvailable[ds.itemCounter.current()] = true;\n    }\n}\n\nlibrary LibMeatStore {\n\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage.meat\");\n  struct StoreState {\n      string butcherName;\n  }\n\n  function diamondStorage() internal pure returns (StoreState storage ds) {\n      bytes32 position = DIAMOND_STORAGE_POSITION;\n      assembly {\n          ds.slot := position\n      }\n  }\n\n  function setButcherName (string memory _butcherName) internal {\n    StoreState storage storeState = diamondStorage();\n    storeState.butcherName = _butcherName;\n  }\n\n  function getButcherName() internal view returns (string memory) {\n    StoreState storage storeState = diamondStorage();\n    return storeState.butcherName;\n  }\n\n}\n\nlibrary LibBeerWineStore {\n\n  error UnderageCustomer();  \n\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage.beer\");\n  struct StoreState {\n      uint256 minAge;\n  }\n\n  function diamondStorage() internal pure returns (StoreState storage ds) {\n      bytes32 position = DIAMOND_STORAGE_POSITION;\n      assembly {\n          ds.slot := position\n      }\n  }\n\n  function setMinAge (uint256 _minAge) internal {\n    StoreState storage storeState = diamondStorage();\n    storeState.minAge = _minAge;\n  }\n\n  function getMinAge() internal view returns (uint256) {\n    StoreState storage storeState = diamondStorage();\n    return storeState.minAge;\n  }\n\n  function enforceMinAge(uint256 age) internal view {\n    if(age < diamondStorage().minAge){\n        revert UnderageCustomer();\n    }    \n  }\n\n\n}\n\nlibrary LibPharmacyWineFacet {\n\n  error UnderageCustomer();  \n\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage.beer\");\n  struct StoreState {\n      bool needPrescription;\n  }\n\n  function diamondStorage() internal pure returns (StoreState storage ds) {\n      bytes32 position = DIAMOND_STORAGE_POSITION;\n      assembly {\n          ds.slot := position\n      }\n  }\n\n  function setNeedPrescription (bool _need) internal {\n    StoreState storage storeState = diamondStorage();\n    storeState.needPrescription = _need;\n  }\n\n\n  function enforcePrescription(bool hasPrescription) internal view {\n    if(diamondStorage().needPrescription && !hasPrescription){\n        revert UnderageCustomer();\n    }    \n  }\n\n\n}"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/PoC/facets/MeatStoreFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// import basic store lib\nimport {LibStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with MeatStoreFacet\nimport {LibMeatStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with \"enforcecontractowner\"\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\"; \n// import some contracts we want to read functions from\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MeatStoreFacet {\n\n    event meatAdded(uint256 idx, string name);\n    event meatRemoved(uint256 idx);\n    using Counters for Counters.Counter;\n\n    function setButcherName (string memory _newButcherName) external {\n        LibDiamond.enforceIsContractOwner();\n        LibMeatStore.setButcherName(_newButcherName);\n    }   \n    function getButcherName() external view returns (string memory _butcherName) {\n        _butcherName = LibMeatStore.getButcherName();\n    }\n    function buyMeat(uint256 _idx) external {\n        LibStore.buyItem(_idx,address(this));\n    }\n    function addMeat(string memory _newMeat) external {\n        LibDiamond.enforceIsContractOwner();\n        LibStore.addItem(_newMeat, address(this));\n    }\n\n    function removeMeat(uint256 _idx) external {\n        LibDiamond.enforceIsContractOwner();\n        LibStore.StoreState storage ds = LibStore.diamondStorage();\n        ds.isProductAvailable[_idx] = false;\n        emit meatRemoved(_idx);\n\n    }\n\n    function getStoreItems() external view returns (string[] memory itemList){\n        itemList = LibStore.getItemsPerStore(address(this));\n    }\n\n}"
    },
    "contracts/PoC/facets/PharmacyWineFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// import basic store lib\nimport {LibStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with MeatStoreFacet\nimport {LibMeatStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with \"enforcecontractowner\"\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\"; \n\n// i want to add a new facets that inherits from BeerWineStore \nimport {BeerWineStoreFacet} from \"./BeerWineStoreFacet.sol\";\n\n// i want to add new Lib functions for this facet\nimport {LibPharmacyWineFacet} from \"../libraries/LibOthers.sol\"; \n\n// will inherit functions from BeerWineStoreFacet\ncontract PharmacyWineFacet is BeerWineStoreFacet{\n\n    function addMedicine(string memory _newMedicine) external {\n        LibDiamond.enforceIsContractOwner();\n        LibStore.addItem(_newMedicine,address(this));\n    }\n\n    function buyMedicine(uint256 _idx, bool hasPrescription) external {\n        LibPharmacyWineFacet.enforcePrescription(hasPrescription);\n        LibStore.buyItem(_idx,address(this));\n    }\n}"
    },
    "contracts/PoC/facets/BeerWineStoreFacet.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// import base lib for Store\nimport {LibStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with MeatStoreFacet\nimport {LibBeerWineStore} from \"../libraries/LibOthers.sol\";\n// import to be able to interact with \"enforcecontractowner\"\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\"; \n// import counter as we using their library\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n\ncontract BeerWineStoreFacet {\n\n    using Counters for Counters.Counter;\n\n    event AlcoholAdded(uint256 idx, string name);\n\n    function addAlcohol(string memory _newBeer) external {\n        LibDiamond.enforceIsContractOwner();\n        LibStore.addItem(_newBeer,address(this));\n    }\n\n    function buyAlcohol(uint256 _idx, uint256 age) external {\n        LibBeerWineStore.enforceMinAge(age);\n        LibStore.buyItem(_idx,address(this));\n    } \n\n    function setMinAge(uint256 _minAge) external {\n        LibBeerWineStore.diamondStorage().minAge = _minAge;\n    }\n    function getBeerStoreItems() external view returns (string[] memory itemList){\n        itemList = LibStore.getItemsPerStore(address(this));\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}